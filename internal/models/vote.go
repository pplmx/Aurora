package models

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
)

// Vote is a struct that represents a vote in the voting system
type Vote struct {
	Token     string // The token of the voter, which is generated by RSA public key
	Candidate string // The name of the candidate that the voter wants to vote for
	Signature string // The signature of the vote, which is generated by RSA private key
}

// SignVote is a function that signs a vote using RSA algorithm and private key
func SignVote(v *Vote, privateKey *rsa.PrivateKey) (string, error) {
	fmt.Println("Signing vote...")

	// Concatenate the token and candidate as the message to be signed
	message := v.Token + v.Candidate

	// Hash the message using SHA256 algorithm
	hashedMessage := sha256.Sum256([]byte(message))

	// Sign the hashed message using RSA private key
	signatureBytes, err := rsa.SignPKCS1v15(rand.Reader, privateKey, sha256.New(), hashedMessage[:])
	if err != nil {
		return "", err
	}

	// Encode the signature bytes to base64 format and return it as signature
	signature := base64.StdEncoding.EncodeToString(signatureBytes)
	return signature, nil

}

// SendVote is a function that sends a vote to the blockchain network and waits for it to be packed into a new block
func SendVote(v *Vote) error {
	fmt.Println("Sending vote...")

	// Here you can use some blockchain services or APIs to send your vote content and signature to the network.
	// For simplicity, we just print them out.

	fmt.Printf("Token: %s\n", v.Token)
	fmt.Printf("Candidate: %s\n", v.Candidate)
	fmt.Printf("Signature: %s\n", v.Signature)

	return nil

}

// VerifyVote is a function that verifies if a vote has been correctly recorded on the blockchain and matches with your intention
func VerifyVote(v *Vote) bool {
	fmt.Println("Verifying vote...")

	// Here you can use some blockchain services or APIs to query your vote on the blockchain.
	// For simplicity, we just assume that it exists and matches with your intention.

	return true

}
