package models

import (
	"crypto/ed25519"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
)

// Vote is a struct that represents a vote in the voting system
type Vote struct {
	Token     string // The token of the voter, which is generated by ed25519 public key
	Candidate string // The name of the candidate that the voter wants to vote for
	Signature string // The signature of the vote, which is generated by ed25519 private key
}

// SignVote is a function that signs a vote using ed25519 algorithm and private key
func SignVote(v *Vote, privateKey *ed25519.PrivateKey) (string, error) {
	fmt.Println("Signing vote...")

	// Concatenate the token and candidate as the message to be signed
	message := v.Token + v.Candidate

	// Hash the message using SHA256 algorithm
	hashedMessage := sha256.Sum256([]byte(message))

	// Sign the hashed message
	signatureBytes := ed25519.Sign(*privateKey, hashedMessage[:])

	// Encode the signature bytes to base64 format and return it as signature
	signature := base64.StdEncoding.EncodeToString(signatureBytes)
	return signature, nil

}

// SendVote is a function that sends a vote to the blockchain network and waits for it to be packed into a new block
func SendVote(v *Vote) error {
	fmt.Println("Sending vote...")

	// Here you can use some blockchain services or APIs to send your vote content and signature to the network.
	// For simplicity, we just print them out.

	fmt.Printf("Token: %s\n", v.Token)
	fmt.Printf("Candidate: %s\n", v.Candidate)
	fmt.Printf("Signature: %s\n", v.Signature)

	return nil

}

// VerifyVote is a function that verifies if a vote has been correctly recorded on the blockchain and matches with your intention
func VerifyVote(v *Vote) bool {
	fmt.Println("Verifying vote...")

	// Here you can use some blockchain services or APIs to query your vote on the blockchain.
	// For simplicity, we just assume that it exists and matches with your intention.

	return true

}
